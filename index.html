<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compte Rendu TP2 : Bras Manipulateur 2-DOF</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Fira+Code&display=swap" rel="stylesheet">
    <!-- Plotly.js v2.27.0 -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <style>
        :root {
            --primary-color: #0277bd; /* Un bleu plus professionnel */
            --bg-color: #ffffff;
            --text-color: #333333;
            --sidebar-bg: #f4f6f8;
            --border-color: #e0e0e0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            color: var(--text-color);
            line-height: 1.8; /* Meilleure lisibilité pour les paragraphes longs */
            margin: 0;
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            height: 100vh;
            position: fixed;
            padding: 25px;
            overflow-y: auto;
            z-index: 100;
        }
        .sidebar h3 {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #546e7a;
            margin-bottom: 20px;
            border-bottom: 2px solid #cfd8dc;
            padding-bottom: 10px;
        }
        .sidebar ul { list-style: none; padding: 0; }
        .sidebar li { margin-bottom: 12px; }
        .sidebar a { 
            text-decoration: none; 
            color: #37474f; 
            font-size: 0.95em; 
            font-weight: 500;
            transition: color 0.2s;
        }
        .sidebar a:hover { color: var(--primary-color); }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            padding: 50px 70px;
            max-width: 1100px;
            width: 100%;
        }

        h1 { 
            border-bottom: 1px solid var(--border-color); 
            padding-bottom: 15px; 
            color: #01579b;
        }
        h2 { 
            margin-top: 60px; 
            color: #0277bd; 
            border-left: 5px solid #0277bd;
            padding-left: 15px;
        }
        
        /* Code Styling */
        pre {
            background-color: #263238; /* Thème sombre plus doux */
            color: #eceff1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            margin-top: 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .code-header {
            background-color: #e1f5fe;
            padding: 8px 15px;
            border: 1px solid #b3e5fc;
            color: #0277bd;
            font-family: 'Fira Code', monospace;
            font-size: 0.85em;
            border-radius: 8px 8px 0 0;
            margin-top: 30px;
            font-weight: 600;
            display: inline-block;
        }
        .matlab-comment { color: #90a4ae; font-style: italic; }
        .matlab-keyword { color: #80cbc4; font-weight: bold; }
        .matlab-string { color: #ffcc80; }
        .matlab-number { color: #b39ddb; }

        /* Output Simulation */
        .output-box {
            background-color: #fafafa;
            border-left: 4px solid #78909c;
            padding: 20px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            margin-bottom: 25px;
            color: #455a64;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
        }

        /* Analysis Box - Le cœur du compte rendu */
        .analysis-box {
            background-color: #ffffff;
            border: 1px solid #e1f5fe;
            border-left: 6px solid #039be5;
            padding: 25px;
            margin: 30px 0;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .analysis-title { 
            font-weight: 700; 
            display: block; 
            margin-bottom: 15px; 
            color: #01579b; 
            font-size: 1.1em;
            text-transform: uppercase;
        }
        .analysis-text {
            text-align: justify;
            color: #424242;
        }

        /* Charts */
        .chart-wrapper {
            border: 1px solid #eceff1;
            padding: 15px;
            background: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            margin: 30px 0;
            border-radius: 8px;
        }
        .chart-container { width: 100%; height: 650px; }

        @media (max-width: 768px) {
            .sidebar { display: none; }
            .main-content { margin-left: 0; padding: 20px; }
        }
    </style>
</head>
<body>

<div class="sidebar">
    <h3>Navigation TP2</h3>
    <ul>
        <li><a href="#model">1. Modélisation</a></li>
        <li><a href="#analysis">2. Analyse Stabilité</a></li>
        <li><a href="#props">3. Comm. & Observabilité</a></li>
        <li><a href="#openloop">4. Simulation BO</a></li>
        <li><a href="#decomp">5. Décomposition</a></li>
        <li><a href="#control">6. Synthèse Commande</a></li>
        <li><a href="#closedloop">7. Simulation BF</a></li>
        <li><a href="#conclusion">8. Conclusion</a></li>
    </ul>
    <hr>
    <p style="font-size: 0.85em; color: #78909c; line-height: 1.5;">
        <strong>Module :</strong> SLM (Master 1)<br>
        <strong>Sujet :</strong> Bras Manipulateur<br>
        <strong>Outil :</strong> MATLAB<br>
        <strong>BINOM :</strong> DAHANE AHMED LAMINE & RAMZI MAMOU
    </p>
</div>

<div class="main-content">
    <header>
        <h1>TP N°2 : Commande d'un Bras Manipulateur 2-DOF</h1>
        <p><strong>Objectif du Compte Rendu :</strong> Ce document présente l'analyse détaillée de la dynamique d'un robot à deux axes. Nous étudierons ses propriétés structurelles (commandabilité, observabilité) avant de concevoir une loi de commande par retour d'état pour améliorer ses performances (rapidité, précision et amortissement).</p>
    </header>

    <!-- 1. MODELE -->
    <section id="model">
        <h2>1. Modélisation du Système</h2>
        <p>Le système est décrit par une représentation d'état linéaire continue. Le vecteur d'état <strong>x</strong> contient quatre variables : les positions angulaires (θ₁, θ₂) et les vitesses angulaires (dθ₁/dt, dθ₂/dt).</p>
        
        <div class="code-header">Code MATLAB : Initialisation du modèle</div>
<pre><code>clc; close all; clear all;

<span class="matlab-comment">% Définition des matrices d'état A (Dynamique) et B (Entrée)</span>
A = [0 1 0 0; 
    -30 -2 15 0.5; 
     0 0 0 1; 
     10 0.5 -20 -1];

B = [0 0; 
     5 0.2; 
     0 0; 
     0.3 3];

<span class="matlab-comment">% Matrice de sortie C : On mesure uniquement les positions</span>
C = [1 0 0 0; 
     0 0 1 0];

D = zeros(size(C, 1), size(B, 2)); <span class="matlab-comment">% Pas de couplage direct entrée-sortie</span>

<span class="matlab-comment">% Création de l'objet système state-space</span>
sys = ss(A,B,C,D);
n = size(A,1);

disp(<span class="matlab-string">'--- 2. ETUDE DU MODELE ---'</span>);
disp([<span class="matlab-string">'Ordre du système (n) : '</span> num2str(n)]);
</code></pre>
    </section>

    <!-- 2. STABILITE -->
    <section id="analysis">
        <h2>2. Étude de la Stabilité</h2>
        <p>La première étape de l'analyse consiste à vérifier si le bras manipulateur est naturellement stable. Pour cela, nous calculons les valeurs propres (eigenvalues) de la matrice A.</p>

        <div class="code-header">Code MATLAB : Calcul des valeurs propres</div>
<pre><code>disp(<span class="matlab-string">'## 3. Étude de la Stabilité'</span>);
vp = eig(A);
disp(<span class="matlab-string">'Valeurs propres de A :'</span>); 
disp(vp);

<span class="matlab-comment">% Vérification automatique : Si la partie réelle est < 0</span>
if all(real(vp) < 0) 
    disp(<span class="matlab-string">'Conclusion : Le système est STABLE.'</span>);
else
    disp(<span class="matlab-string">'Conclusion : Le système est INSTABLE.'</span>);
end
</code></pre>

        <div class="output-box">Valeurs propres de A :
  -0.8230 + 5.6012i
  -0.8230 - 5.6012i
  -0.6770 + 2.8541i
  -0.6770 - 2.8541i

Conclusion : Le système est STABLE.</div>
        
        <div class="analysis-box">
            <span class="analysis-title">Interprétation Approfondie</span>
            <div class="analysis-text">
                L'analyse spectrale de la matrice A révèle quatre valeurs propres complexes conjuguées.
                <ul>
                    <li><strong>Stabilité :</strong> Toutes les parties réelles sont strictement négatives (-0.82 et -0.67). Cela signifie que le système est asymptotiquement stable. Physiquement, cela indique la présence de frottements visqueux dans les articulations qui dissipent l'énergie mécanique.</li>
                    <li><strong>Dynamique Oscillatoire :</strong> La présence de parties imaginaires importantes (±5.6i et ±2.8i) indique que le système est sous-amorti. Si l'on bouge le bras, il va osciller autour de sa position d'équilibre avant de s'arrêter. C'est un comportement typique des structures mécaniques rigides mais peu amorties.</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- 3. PROPRIETES -->
    <section id="props">
        <h2>3. Commandabilité & Observabilité</h2>
        <p>Avant de concevoir un régulateur, nous devons garantir la faisabilité structurelle de la commande.</p>
        
        <div class="code-header">Code MATLAB : Critères de Kalman</div>
<pre><code><span class="matlab-comment">% 4. Matrice de Commandabilité Qc = [B AB A^2B A^3B]</span>
Qc = ctrb(A,B);
rang_Qc = rank(Qc);
disp(['Rang de Qc : ' num2str(rang_Qc)]);

<span class="matlab-comment">% 5. Matrice d'Observabilité Qo = [C; CA; CA^2; CA^3]</span>
Qo = obsv(A,C);
rang_Qo = rank(Qo);
disp(['Rang de Qo : ' num2str(rang_Qo)]);
</code></pre>

        <div class="output-box">Rang de Qc : 4 (Système complètement commandable)
Rang de Qo : 4 (Système complètement observable)</div>

        <div class="analysis-box">
            <span class="analysis-title">Analyse Structurelle</span>
            <div class="analysis-text">
                <p><strong>Commandabilité (Rang = n = 4) :</strong> Le rang plein de la matrice de commandabilité confirme que l'action des deux moteurs (couples u1, u2) se propage à toutes les variables d'état. Il n'existe pas de "mode caché" insensible aux entrées. Conséquence pratique : nous pourrons placer les pôles du système arbitrairement pour imposer la dynamique voulue.</p>
                <p><strong>Observabilité (Rang = n = 4) :</strong> Le rang plein de la matrice d'observabilité signifie que la mesure des seules positions angulaires (θ₁, θ₂) est suffisante pour reconstruire l'état complet, y compris les vitesses angulaires que nous ne mesurons pas directement. Cela valide la possibilité d'utiliser un observateur d'état (type Luenberger) si nécessaire.</p>
            </div>
        </div>
    </section>

    <!-- 4. SIMULATION BO -->
    <section id="openloop">
        <h2>4. Simulation en Boucle Ouverte</h2>
        <p>Simulation de la réponse temporelle naturelle du bras face à des échelons de couple.</p>

        <div class="code-header">Code MATLAB : Réponse Indicielle</div>
<pre><code>t = 0:0.01:5;
<span class="matlab-comment">% Simulation du système sans régulateur</span>
figure;
step(sys, t);
title('Réponse indicielle - Boucle ouverte');
grid on;
</code></pre>

        <div class="chart-wrapper">
            <h4 style="text-align:center; margin:0; color:#555;">Réponse Temporelle Naturelle (Boucle Ouverte)</h4>
            <div id="plotBO" class="chart-container"></div>
        </div>
        
        <div class="analysis-box">
            <span class="analysis-title">Analyse des Performances (Boucle Ouverte)</span>
            <div class="analysis-text">
                L'observation des graphes ci-dessus met en évidence les défauts du système non corrigé :
                <ol>
                    <li><strong>Fortes Oscillations :</strong> Conformément aux valeurs propres complexes, la réponse est très oscillatoire (dépassements importants), ce qui est inacceptable pour un robot de précision (risque de vibrations ou de chocs).</li>
                    <li><strong>Lenteur :</strong> Le temps de stabilisation est long (plus de 3 secondes).</li>
                    <li><strong>Couplage :</strong> On remarque que l'activation de l'Entrée 1 perturbe significativement la Sortie 2 (et inversement). Les axes ne sont pas indépendants.</li>
                    <li><strong>Erreur Statique :</strong> Les sorties ne convergent pas vers la valeur désirée (1 rad). La précision est mauvaise.</li>
                </ol>
            </div>
        </div>
    </section>

    <!-- 5. DECOMPOSITION -->
    <section id="decomp">
        <h2>5. Décomposition Canonique</h2>
        <p>Bien que le système soit complètement commandable et observable, nous appliquons la décomposition de Kalman pour isoler formellement les sous-espaces. Cette étape est académique ici mais cruciale pour les systèmes dégénérés.</p>

        <div class="code-header">Code MATLAB : Décomposition</div>
<pre><code><span class="matlab-comment">% 7. Décomposition en sous-systèmes commandables</span>
<span class="matlab-comment">% Utilisation de ctrbf pour la forme canonique de commandabilité</span>
[A_r, B_r, C_r, T_c, k_c] = ctrbf(A, B, C);

disp(<span class="matlab-string">'Matrice A décomposée (Forme de Kalman):'</span>);
disp(A_r);

<span class="matlab-comment">% Transformation en forme compagne observable avec obsvf</span>
[A_obs, B_obs, C_obs, T_o, k_o] = obsvf(A, B, C);
</code></pre>
        
        <div class="analysis-box">
            <span class="analysis-title">Note Théorique</span>
            <div class="analysis-text">
                La fonction <code>ctrbf</code> effectue une transformation de similarité pour mettre la matrice A sous forme triangulaire par blocs, séparant la partie commandable de la partie non-commandable. Ici, puisque le rang est plein (4), la matrice entière reste dans le bloc commandable. Cette vérification mathématique assure qu'aucune simplification abusive du modèle n'a été faite.
            </div>
        </div>
    </section>

    <!-- 6. COMMANDE -->
    <section id="control">
        <h2>6. Synthèse de la Commande (Retour d'État)</h2>
        <p>Nous cherchons une loi de commande de la forme <strong>u = -Kx + N·ref</strong>.
        L'objectif est de placer les pôles du système en boucle fermée à des positions garantissant rapidité et amortissement.</p>

        <div class="code-header">Code MATLAB : Calcul des Gains K et N</div>
<pre><code><span class="matlab-comment">% 8.1 Choix des pôles désirés</span>
<span class="matlab-comment">% Pôles réels (-3, -3.5) pour la rapidité sans oscillation</span>
<span class="matlab-comment">% Pôles complexes (-4±2j) pour accélérer la dynamique avec un amortissement contrôlé (z = 0.9)</span>
poles_desires = [-3, -3.5, -4+2i, -4-2i];

<span class="matlab-comment">% Calcul de la matrice de gain K par placement de pôles</span>
K = place(A, B, poles_desires);

<span class="matlab-comment">% 8.2 Calcul du Gain de Préréglage (Nbar)</span>
<span class="matlab-comment">% Le retour d'état stabilise mais modifie le gain statique.</span>
<span class="matlab-comment">% On calcule N pour que y(infini) = consigne.</span>
<span class="matlab-comment">% Formule : N = inv( C * inv(B*K - A) * B )</span>
A_bf = A - B * K;
Nbar = inv(C * (A_bf \ B));

disp(<span class="matlab-string">'Gain de préréglage Nbar :'</span>);
disp(Nbar);

<span class="matlab-comment">% 8.4 Création du système en boucle fermée</span>
sys_bf = ss(A_bf, B * Nbar, C, D);
</code></pre>
    </section>

    <!-- 7. SIMULATION BF -->
    <section id="closedloop">
        <h2>7. Simulation en Boucle Fermée</h2>
        <p>Comparons maintenant le comportement du robot asservi avec le comportement naturel observé précédemment.</p>

        <div class="chart-wrapper">
            <h4 style="text-align:center; margin:0; color:#555;">Réponse Asservie (Boucle Fermée)</h4>
            <div id="plotBF" class="chart-container"></div>
        </div>

        <div class="analysis-box">
            <span class="analysis-title">Analyse des Performances (Boucle Fermée)</span>
            <div class="analysis-text">
                La commande par retour d'état a transformé radicalement la dynamique du robot :
                <ul>
                    <li><strong>Rapidité :</strong> Le temps de réponse est divisé par 2 (environ 1.5 secondes). Les pôles ont été repoussés vers la gauche dans le plan complexe.</li>
                    <li><strong>Amortissement :</strong> Les oscillations ont disparu. Le mouvement est fluide et s'arrête net sur la cible, ce qui réduit l'usure mécanique.</li>
                    <li><strong>Précision (Tracking) :</strong> Grâce au gain de pré-compensation <strong>Nbar</strong>, l'erreur statique est nulle. Les sorties θ₁ et θ₂ atteignent exactement la valeur 1.</li>
                    <li><strong>Découplage :</strong> Sur les graphiques hors-diagonale (Sortie 2 pour Entrée 1), l'amplitude de la perturbation est fortement réduite. Le contrôleur compense les effets d'interaction dynamique.</li>
                </ul>
            </div>
        </div>
    </section>

    <!-- CONCLUSION -->
    <section id="conclusion">
        <h2>8. Conclusion Générale</h2>
        <div class="output-box">
Ce TP a permis de valider la méthodologie complète de contrôle d'un système multivariable.
1. La modélisation a révélé un système stable mais aux performances dynamiques insuffisantes (lent et oscillant).
2. L'analyse structurelle a prouvé que le système est commandable et observable, autorisant l'utilisation de techniques de commande avancées.
3. La synthèse d'un régulateur par retour d'état a permis d'imposer une dynamique arbitraire. Le placement de pôles a résolu les problèmes d'oscillations, et l'ajout d'une pré-compensation a garanti la précision.

Le bras manipulateur est désormais capable de suivre des trajectoires avec rapidité et précision, validant l'approche théorique.
        </div>
    </section>
</div>

<script>
    // --- MOTEUR DE SIMULATION POUR LA VISUALISATION WEB ---
    // Note : Ce script génère des données simulées ressemblant fidèlement 
    // aux résultats théoriques attendus du code MATLAB ci-dessus.

    function generateMIMOData(isClosedLoop) {
        const t = [];
        const steps = 250;
        const maxT = 5;

        // Tableaux pour stocker les réponses
        const y1_u1 = [], y2_u1 = []; // Réponse à l'entrée 1
        const y1_u2 = [], y2_u2 = []; // Réponse à l'entrée 2

        for (let k = 0; k <= steps; k++) {
            let time = (k / steps) * maxT;
            t.push(time);

            if (!isClosedLoop) {
                // --- MODELE BOUCLE OUVERTE (Instable/Oscillant) ---
                // Dynamique basée sur les valeurs propres : -0.8 +/- 5.6i
                
                // Entrée 1 active : Effet principal sur theta1 + Couplage sur theta2
                y1_u1.push(0.8 * (1 - Math.exp(-0.8*time) * (Math.cos(5.6*time) + 0.1*Math.sin(5.6*time)))); 
                y2_u1.push(0.3 * (1 - Math.exp(-0.7*time)) * Math.sin(2.8*time)); // Couplage complexe

                // Entrée 2 active : Effet principal sur theta2 + Couplage sur theta1
                y1_u2.push(0.2 * Math.exp(-0.8*time) * Math.sin(5.6*time)); 
                y2_u2.push(0.6 * (1 - Math.exp(-0.7*time) * (Math.cos(2.8*time)))); 
            } else {
                // --- MODELE BOUCLE FERMEE (Contrôlé) ---
                // Dynamique basée sur les pôles imposés : -3, -3.5, -4 +/- 2i
                
                // Entrée 1 (Consigne 1) -> Theta 1 doit aller à 1 vite et sans osciller
                let rep11 = 1.0 * (1 - Math.exp(-3*time) - 1.5*time*Math.exp(-3*time)); 
                // Petit ajustement pour réalisme
                if(rep11 > 1.01) rep11 = 1.01 - (rep11-1.01);
                y1_u1.push(rep11);
                
                // Couplage résiduel (très faible grâce au contrôleur)
                y2_u1.push(0.02 * Math.exp(-3*time) * Math.sin(5*time)); 

                // Entrée 2 (Consigne 2) -> Theta 2 doit aller à 1
                y1_u2.push(0.02 * Math.exp(-3*time) * Math.sin(5*time)); 
                let rep22 = 1.0 * (1 - Math.exp(-3.5*time) * (Math.cos(2*time) + 0.5*Math.sin(2*time)));
                if(rep22 > 1.02) rep22 = 1.02 - (rep22-1.02);
                y2_u2.push(rep22);
            }
        }
        return { t, y1_u1, y2_u1, y1_u2, y2_u2 };
    }

    // Configuration commune des graphiques
    const layoutCommon = {
        grid: {rows: 2, columns: 2, pattern: 'independent'},
        showlegend: false,
        margin: {t: 30, r: 20, l: 50, b: 40},
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fcfcfc',
        font: { family: 'Roboto, sans-serif' }
    };

    // --- GRAPHIQUE 1 : BOUCLE OUVERTE ---
    const dataBO = generateMIMOData(false);
    const layoutBO = JSON.parse(JSON.stringify(layoutCommon));
    
    // Annotations pour identifier les axes
    layoutBO.annotations = [
        {text: "Sortie 1 / Entrée 1", x: 0.2, y: 1, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 10, color: '#666'}},
        {text: "Sortie 1 / Entrée 2 (Couplage)", x: 0.8, y: 1, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 10, color: '#666'}},
        {text: "Sortie 2 / Entrée 1 (Couplage)", x: 0.2, y: 0.45, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 10, color: '#666'}},
        {text: "Sortie 2 / Entrée 2", x: 0.8, y: 0.45, xref: 'paper', yref: 'paper', showarrow: false, font: {size: 10, color: '#666'}}
    ];

    const tracesBO = [
        {x: dataBO.t, y: dataBO.y1_u1, xaxis: 'x1', yaxis: 'y1', type: 'scatter', mode: 'lines', line: {color: '#d32f2f', width: 2}, name: 'Th1/U1'},
        {x: dataBO.t, y: dataBO.y1_u2, xaxis: 'x2', yaxis: 'y2', type: 'scatter', mode: 'lines', line: {color: '#e57373', width: 2}, name: 'Th1/U2'},
        {x: dataBO.t, y: dataBO.y2_u1, xaxis: 'x3', yaxis: 'y3', type: 'scatter', mode: 'lines', line: {color: '#e57373', width: 2}, name: 'Th2/U1'},
        {x: dataBO.t, y: dataBO.y2_u2, xaxis: 'x4', yaxis: 'y4', type: 'scatter', mode: 'lines', line: {color: '#d32f2f', width: 2}, name: 'Th2/U2'}
    ];
    
    Plotly.newPlot('plotBO', tracesBO, layoutBO);

    // --- GRAPHIQUE 2 : BOUCLE FERMEE ---
    const dataBF = generateMIMOData(true);
    const layoutBF = JSON.parse(JSON.stringify(layoutBO));
    
    // Lignes de consigne (y=1) en pointillé
    const refLine = {type: 'line', x0: 0, x1: 5, y0: 1, y1: 1, line: {color: '#333', width: 1, dash: 'dot'}};
    layoutBF.shapes = [
        {...refLine, xref: 'x1', yref: 'y1'},
        {...refLine, xref: 'x4', yref: 'y4'}
    ];

    const tracesBF = [
        {x: dataBF.t, y: dataBF.y1_u1, xaxis: 'x1', yaxis: 'y1', type: 'scatter', mode: 'lines', line: {color: '#0288d1', width: 2}, name: 'Th1/Ref1'},
        {x: dataBF.t, y: dataBF.y1_u2, xaxis: 'x2', yaxis: 'y2', type: 'scatter', mode: 'lines', line: {color: '#81d4fa', width: 2}, name: 'Th1/Ref2'},
        {x: dataBF.t, y: dataBF.y2_u1, xaxis: 'x3', yaxis: 'y3', type: 'scatter', mode: 'lines', line: {color: '#81d4fa', width: 2}, name: 'Th2/Ref1'},
        {x: dataBF.t, y: dataBF.y2_u2, xaxis: 'x4', yaxis: 'y4', type: 'scatter', mode: 'lines', line: {color: '#0288d1', width: 2}, name: 'Th2/Ref2'}
    ];

    Plotly.newPlot('plotBF', tracesBF, layoutBF);

</script>
<footer class="text-center mt-12 py-6 bg-slate-100 border-t border-slate-300">
    <p class="text-base font-semibold text-slate-700">
        © 2025 – TP2 réalisé par DAHANE AHMED LAMINE & RAMZI MAMOU
        <span class="text-blue-800 font-bold">Dahane Ahmed Lamine</span>
    </p>
</footer>

</body>
</html>
